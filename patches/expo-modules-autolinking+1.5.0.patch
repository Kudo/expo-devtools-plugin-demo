diff --git a/node_modules/expo-modules-autolinking/.npmignore b/node_modules/expo-modules-autolinking/.npmignore
new file mode 100644
index 0000000..3aab27e
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/.npmignore
@@ -0,0 +1,11 @@
+# @generated by expo-module-scripts
+
+# Exclude all top-level hidden directories by convention
+/.*/
+
+__mocks__
+__tests__
+
+/babel.config.js
+/android/src/androidTest/
+/android/src/test/
diff --git a/node_modules/expo-modules-autolinking/CHANGELOG.md b/node_modules/expo-modules-autolinking/CHANGELOG.md
index 3ee14fe..c0dc38f 100644
--- a/node_modules/expo-modules-autolinking/CHANGELOG.md
+++ b/node_modules/expo-modules-autolinking/CHANGELOG.md
@@ -10,6 +10,12 @@
 
 ### 💡 Others
 
+## 1.5.1 — 2023-08-22
+
+### 🐛 Bug fixes
+
+- Fixed `expo_patch_react_imports!` missing some lines with spaces before or after the imports. ([#23923](https://github.com/expo/expo/pull/23923) by [@liamjones](https://github.com/liamjones))
+
 ## 1.5.0 — 2023-06-21
 
 ### 🎉 New features
diff --git a/node_modules/expo-modules-autolinking/babel.config.js b/node_modules/expo-modules-autolinking/babel.config.js
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js b/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js
index b69f9a1..9b62410 100644
--- a/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js
+++ b/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js
@@ -34,7 +34,7 @@ async function generateReactHeaderSetAsync(reactHeaderDir) {
 async function patchFileAsync(headerSet, file, dryRun) {
     let changed = false;
     const content = await fs_extra_1.default.readFile(file, 'utf-8');
-    let transformContent = content.replace(/^#import\s+"(.+)"$/gm, (match, headerName) => {
+    let transformContent = content.replace(/(?<=^\s*)#import\s+"(.+)"(?=\s*$)/gm, (match, headerName) => {
         // `#import "RCTBridge.h"` -> `#import <React/RCTBridge.h>`
         if (headerSet.has(headerName)) {
             changed = true;
@@ -51,7 +51,7 @@ async function patchFileAsync(headerSet, file, dryRun) {
         // Otherwise, return original import
         return match;
     });
-    transformContent = transformContent.replace(/^#(if|elif)\s+__has_include\("(.+)"\)$/gm, (match, ifPrefix, headerName) => {
+    transformContent = transformContent.replace(/(?<=^\s*)#(if|elif)\s+__has_include\("(.+)"\)(?=\s*$)/gm, (match, ifPrefix, headerName) => {
         // `#if __has_include("RCTBridge.h")` -> `#if __has_include(<React/RCTBridge.h>)`
         if (headerSet.has(headerName)) {
             changed = true;
diff --git a/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js.map b/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js.map
index 6005c68..46e95ec 100644
--- a/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js.map
+++ b/node_modules/expo-modules-autolinking/build/ReactImportsPatcher.js.map
@@ -1 +1 @@
-{"version":3,"file":"ReactImportsPatcher.js","sourceRoot":"","sources":["../src/ReactImportsPatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018-present 650 Industries. All rights reserved.\n\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { PatchReactImportsOptions } from './types';\n\n/**\n * Remove all double-quoted react header imports\n * @param dirs target directories to patch\n * @param options PatchReactImportsOptions\n */\nexport async function patchReactImportsAsync(dirs: string[], options: PatchReactImportsOptions) {\n  const headerSet = await generateReactHeaderSetAsync(\n    path.join(options.podsRoot, 'Headers', 'Public', 'React-Core', 'React')\n  );\n  await Promise.all(dirs.map((dir) => patchDirAsync(headerSet, dir, options.dryRun)));\n}\n\n/**\n * Generate `React-Core` public header names as a set, will transform necessary headers based on this set.\n */\nasync function generateReactHeaderSetAsync(reactHeaderDir: string): Promise<Set<string>> {\n  const files = await glob('*.h', { cwd: reactHeaderDir });\n  return new Set(files);\n}\n\n/**\n * Patch imports from a file\n * @param headerSet prebuilt React-Core header set\n * @param file target patch file\n * @param dryRun true if not writing changes to file\n */\nexport async function patchFileAsync(headerSet: Set<string>, file: string, dryRun: boolean) {\n  let changed = false;\n  const content = await fs.readFile(file, 'utf-8');\n  let transformContent = content.replace(\n    /^#import\\s+\"(.+)\"$/gm,\n    (match: string, headerName: string): string => {\n      // `#import \"RCTBridge.h\"` -> `#import <React/RCTBridge.h>`\n      if (headerSet.has(headerName)) {\n        changed = true;\n        return `#import <React/${headerName}>`;\n      }\n\n      // `#import \"React/RCTBridge.h\"` -> `#import <React/RCTBridge.h>`\n      if (headerName.startsWith('React/')) {\n        const name = headerName.substring(6);\n        if (headerSet.has(name)) {\n          changed = true;\n          return `#import <React/${name}>`;\n        }\n      }\n\n      // Otherwise, return original import\n      return match;\n    }\n  );\n\n  transformContent = transformContent.replace(\n    /^#(if|elif)\\s+__has_include\\(\"(.+)\"\\)$/gm,\n    (match: string, ifPrefix: string, headerName: string): string => {\n      // `#if __has_include(\"RCTBridge.h\")` -> `#if __has_include(<React/RCTBridge.h>)`\n      if (headerSet.has(headerName)) {\n        changed = true;\n        return `#${ifPrefix} __has_include(<React/${headerName}>)`;\n      }\n\n      // `#if __has_include(\"React/RCTBridge.h\")` -> `#if __has_include(<React/RCTBridge.h>)`\n      if (headerName.startsWith('React/')) {\n        const name = headerName.substring(6);\n        if (headerSet.has(name)) {\n          changed = true;\n          return `#${ifPrefix} __has_include(<React/${name}>)`;\n        }\n      }\n\n      // Otherwise, return original import\n      return match;\n    }\n  );\n\n  if (changed) {\n    console.log(`Patching imports for file: ${file}`);\n    if (!dryRun) {\n      await fs.writeFile(file, transformContent);\n    }\n  }\n}\n\n/**\n * Patch imports from a directory\n * @param headerSet prebuilt React-Core header set\n * @param file target patch file\n * @param dryRun true if not writing changes to file\n */\nasync function patchDirAsync(headerSet: Set<string>, dir: string, dryRun: boolean) {\n  const files = await glob('**/*.{h,m,mm}', { cwd: dir, absolute: true });\n  return Promise.all(files.map((file) => patchFileAsync(headerSet, file, dryRun)));\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ReactImportsPatcher.js","sourceRoot":"","sources":["../src/ReactImportsPatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018-present 650 Industries. All rights reserved.\n\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { PatchReactImportsOptions } from './types';\n\n/**\n * Remove all double-quoted react header imports\n * @param dirs target directories to patch\n * @param options PatchReactImportsOptions\n */\nexport async function patchReactImportsAsync(dirs: string[], options: PatchReactImportsOptions) {\n  const headerSet = await generateReactHeaderSetAsync(\n    path.join(options.podsRoot, 'Headers', 'Public', 'React-Core', 'React')\n  );\n  await Promise.all(dirs.map((dir) => patchDirAsync(headerSet, dir, options.dryRun)));\n}\n\n/**\n * Generate `React-Core` public header names as a set, will transform necessary headers based on this set.\n */\nasync function generateReactHeaderSetAsync(reactHeaderDir: string): Promise<Set<string>> {\n  const files = await glob('*.h', { cwd: reactHeaderDir });\n  return new Set(files);\n}\n\n/**\n * Patch imports from a file\n * @param headerSet prebuilt React-Core header set\n * @param file target patch file\n * @param dryRun true if not writing changes to file\n */\nexport async function patchFileAsync(headerSet: Set<string>, file: string, dryRun: boolean) {\n  let changed = false;\n  const content = await fs.readFile(file, 'utf-8');\n  let transformContent = content.replace(\n    /(?<=^\\s*)#import\\s+\"(.+)\"(?=\\s*$)/gm,\n    (match: string, headerName: string): string => {\n      // `#import \"RCTBridge.h\"` -> `#import <React/RCTBridge.h>`\n      if (headerSet.has(headerName)) {\n        changed = true;\n        return `#import <React/${headerName}>`;\n      }\n\n      // `#import \"React/RCTBridge.h\"` -> `#import <React/RCTBridge.h>`\n      if (headerName.startsWith('React/')) {\n        const name = headerName.substring(6);\n        if (headerSet.has(name)) {\n          changed = true;\n          return `#import <React/${name}>`;\n        }\n      }\n\n      // Otherwise, return original import\n      return match;\n    }\n  );\n\n  transformContent = transformContent.replace(\n    /(?<=^\\s*)#(if|elif)\\s+__has_include\\(\"(.+)\"\\)(?=\\s*$)/gm,\n    (match: string, ifPrefix: string, headerName: string): string => {\n      // `#if __has_include(\"RCTBridge.h\")` -> `#if __has_include(<React/RCTBridge.h>)`\n      if (headerSet.has(headerName)) {\n        changed = true;\n        return `#${ifPrefix} __has_include(<React/${headerName}>)`;\n      }\n\n      // `#if __has_include(\"React/RCTBridge.h\")` -> `#if __has_include(<React/RCTBridge.h>)`\n      if (headerName.startsWith('React/')) {\n        const name = headerName.substring(6);\n        if (headerSet.has(name)) {\n          changed = true;\n          return `#${ifPrefix} __has_include(<React/${name}>)`;\n        }\n      }\n\n      // Otherwise, return original import\n      return match;\n    }\n  );\n\n  if (changed) {\n    console.log(`Patching imports for file: ${file}`);\n    if (!dryRun) {\n      await fs.writeFile(file, transformContent);\n    }\n  }\n}\n\n/**\n * Patch imports from a directory\n * @param headerSet prebuilt React-Core header set\n * @param file target patch file\n * @param dryRun true if not writing changes to file\n */\nasync function patchDirAsync(headerSet: Set<string>, dir: string, dryRun: boolean) {\n  const files = await glob('**/*.{h,m,mm}', { cwd: dir, absolute: true });\n  return Promise.all(files.map((file) => patchFileAsync(headerSet, file, dryRun)));\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.d.ts b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.d.ts
index fe041dd..97551a2 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.d.ts
+++ b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.d.ts
@@ -22,9 +22,9 @@ interface ExtraDependencies {
 /**
  * Gets the `expo-build-properties` settings from the app config.
  */
-export declare function getBuildPropertiesAsync(): Promise<Record<string, any>>;
+export declare function getBuildPropertiesAsync(projectRoot: string): Promise<Record<string, any>>;
 /**
  * Resolves the extra dependencies from `expo-build-properties` settings.
  */
-export declare function resolveExtraDependenciesAsync(): Promise<Partial<ExtraDependencies>>;
+export declare function resolveExtraDependenciesAsync(projectRoot: string): Promise<Partial<ExtraDependencies>>;
 export {};
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js
index b694680..29abd18 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js
+++ b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js
@@ -10,9 +10,9 @@ const mergeLinkingOptions_1 = require("./mergeLinkingOptions");
 /**
  * Gets the `expo-build-properties` settings from the app config.
  */
-async function getBuildPropertiesAsync() {
-    const projectRoot = path_1.default.dirname(mergeLinkingOptions_1.projectPackageJsonPath);
-    const { exp: config } = await (0, config_1.getConfig)(projectRoot, { skipSDKVersionRequirement: true });
+async function getBuildPropertiesAsync(projectRoot) {
+    const projectPackageRoot = path_1.default.dirname(await (0, mergeLinkingOptions_1.getProjectPackageJsonPathAsync)(projectRoot));
+    const { exp: config } = await (0, config_1.getConfig)(projectPackageRoot, { skipSDKVersionRequirement: true });
     const buildPropertiesPlugin = config.plugins?.find((item) => item[0] === 'expo-build-properties')?.[1];
     return buildPropertiesPlugin ?? {};
 }
@@ -20,8 +20,8 @@ exports.getBuildPropertiesAsync = getBuildPropertiesAsync;
 /**
  * Resolves the extra dependencies from `expo-build-properties` settings.
  */
-async function resolveExtraDependenciesAsync() {
-    const buildProps = await getBuildPropertiesAsync();
+async function resolveExtraDependenciesAsync(projectRoot) {
+    const buildProps = await getBuildPropertiesAsync(projectRoot);
     return {
         androidMavenRepos: buildProps.android?.extraMavenRepos ?? [],
         iosPods: buildProps.ios?.extraPods ?? {},
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js.map b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js.map
index a312e68..a8d543c 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js.map
+++ b/node_modules/expo-modules-autolinking/build/autolinking/extraDependencies.js.map
@@ -1 +1 @@
-{"version":3,"file":"extraDependencies.js","sourceRoot":"","sources":["../../src/autolinking/extraDependencies.ts"],"names":[],"mappings":";;;;;;AAAA,yCAAyC;AACzC,gDAAwB;AAExB,+DAA+D;AA0B/D;;GAEG;AACI,KAAK,UAAU,uBAAuB;IAC3C,MAAM,WAAW,GAAG,cAAI,CAAC,OAAO,CAAC,4CAAsB,CAAC,CAAC;IACzD,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,kBAAS,EAAC,WAAW,EAAE,EAAE,yBAAyB,EAAE,IAAI,EAAE,CAAC,CAAC;IAC1F,MAAM,qBAAqB,GAAG,MAAM,CAAC,OAAO,EAAE,IAAI,CAChD,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,uBAAuB,CAC9C,EAAE,CAAC,CAAC,CAAC,CAAC;IACP,OAAO,qBAAqB,IAAI,EAAE,CAAC;AACrC,CAAC;AAPD,0DAOC;AAED;;GAEG;AACI,KAAK,UAAU,6BAA6B;IACjD,MAAM,UAAU,GAAG,MAAM,uBAAuB,EAAE,CAAC;IACnD,OAAO;QACL,iBAAiB,EAAE,UAAU,CAAC,OAAO,EAAE,eAAe,IAAI,EAAE;QAC5D,OAAO,EAAE,UAAU,CAAC,GAAG,EAAE,SAAS,IAAI,EAAE;KACzC,CAAC;AACJ,CAAC;AAND,sEAMC","sourcesContent":["import { getConfig } from '@expo/config';\nimport path from 'path';\n\nimport { projectPackageJsonPath } from './mergeLinkingOptions';\n\ninterface AndroidMavenRepository {\n  url: string;\n}\n\ninterface IosPod {\n  name: string;\n  version?: string;\n  configurations?: string[];\n  modular_headers?: boolean;\n  source?: string;\n  path?: string;\n  podspec?: string;\n  testspecs?: string[];\n  git?: string;\n  branch?: string;\n  tag?: string;\n  commit?: string;\n}\n\ninterface ExtraDependencies {\n  androidMavenRepos: AndroidMavenRepository[];\n  iosPods?: IosPod[];\n}\n\n/**\n * Gets the `expo-build-properties` settings from the app config.\n */\nexport async function getBuildPropertiesAsync(): Promise<Record<string, any>> {\n  const projectRoot = path.dirname(projectPackageJsonPath);\n  const { exp: config } = await getConfig(projectRoot, { skipSDKVersionRequirement: true });\n  const buildPropertiesPlugin = config.plugins?.find(\n    (item) => item[0] === 'expo-build-properties'\n  )?.[1];\n  return buildPropertiesPlugin ?? {};\n}\n\n/**\n * Resolves the extra dependencies from `expo-build-properties` settings.\n */\nexport async function resolveExtraDependenciesAsync(): Promise<Partial<ExtraDependencies>> {\n  const buildProps = await getBuildPropertiesAsync();\n  return {\n    androidMavenRepos: buildProps.android?.extraMavenRepos ?? [],\n    iosPods: buildProps.ios?.extraPods ?? {},\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"extraDependencies.js","sourceRoot":"","sources":["../../src/autolinking/extraDependencies.ts"],"names":[],"mappings":";;;;;;AAAA,yCAAyC;AACzC,gDAAwB;AAExB,+DAAuE;AA0BvE;;GAEG;AACI,KAAK,UAAU,uBAAuB,CAAC,WAAmB;IAC/D,MAAM,kBAAkB,GAAG,cAAI,CAAC,OAAO,CAAC,MAAM,IAAA,oDAA8B,EAAC,WAAW,CAAC,CAAC,CAAC;IAC3F,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,kBAAS,EAAC,kBAAkB,EAAE,EAAE,yBAAyB,EAAE,IAAI,EAAE,CAAC,CAAC;IACjG,MAAM,qBAAqB,GAAG,MAAM,CAAC,OAAO,EAAE,IAAI,CAChD,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,uBAAuB,CAC9C,EAAE,CAAC,CAAC,CAAC,CAAC;IACP,OAAO,qBAAqB,IAAI,EAAE,CAAC;AACrC,CAAC;AAPD,0DAOC;AAED;;GAEG;AACI,KAAK,UAAU,6BAA6B,CACjD,WAAmB;IAEnB,MAAM,UAAU,GAAG,MAAM,uBAAuB,CAAC,WAAW,CAAC,CAAC;IAC9D,OAAO;QACL,iBAAiB,EAAE,UAAU,CAAC,OAAO,EAAE,eAAe,IAAI,EAAE;QAC5D,OAAO,EAAE,UAAU,CAAC,GAAG,EAAE,SAAS,IAAI,EAAE;KACzC,CAAC;AACJ,CAAC;AARD,sEAQC","sourcesContent":["import { getConfig } from '@expo/config';\nimport path from 'path';\n\nimport { getProjectPackageJsonPathAsync } from './mergeLinkingOptions';\n\ninterface AndroidMavenRepository {\n  url: string;\n}\n\ninterface IosPod {\n  name: string;\n  version?: string;\n  configurations?: string[];\n  modular_headers?: boolean;\n  source?: string;\n  path?: string;\n  podspec?: string;\n  testspecs?: string[];\n  git?: string;\n  branch?: string;\n  tag?: string;\n  commit?: string;\n}\n\ninterface ExtraDependencies {\n  androidMavenRepos: AndroidMavenRepository[];\n  iosPods?: IosPod[];\n}\n\n/**\n * Gets the `expo-build-properties` settings from the app config.\n */\nexport async function getBuildPropertiesAsync(projectRoot: string): Promise<Record<string, any>> {\n  const projectPackageRoot = path.dirname(await getProjectPackageJsonPathAsync(projectRoot));\n  const { exp: config } = await getConfig(projectPackageRoot, { skipSDKVersionRequirement: true });\n  const buildPropertiesPlugin = config.plugins?.find(\n    (item) => item[0] === 'expo-build-properties'\n  )?.[1];\n  return buildPropertiesPlugin ?? {};\n}\n\n/**\n * Resolves the extra dependencies from `expo-build-properties` settings.\n */\nexport async function resolveExtraDependenciesAsync(\n  projectRoot: string\n): Promise<Partial<ExtraDependencies>> {\n  const buildProps = await getBuildPropertiesAsync(projectRoot);\n  return {\n    androidMavenRepos: buildProps.android?.extraMavenRepos ?? [],\n    iosPods: buildProps.ios?.extraPods ?? {},\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/findModules.js b/node_modules/expo-modules-autolinking/build/autolinking/findModules.js
index 8468bb8..c78e956 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/findModules.js
+++ b/node_modules/expo-modules-autolinking/build/autolinking/findModules.js
@@ -56,10 +56,10 @@ async function findModulesAsync(providedOptions) {
     // (excluding custom native modules path)
     // Workspace root usually doesn't specify all its dependencies (see Expo Go),
     // so in this case we should link everything.
-    if (options.searchPaths.length <= 1) {
+    if (options.searchPaths.length <= 1 || options.onlyProjectDeps === false) {
         return searchResults;
     }
-    return filterToProjectDependencies(searchResults, {
+    return await filterToProjectDependenciesAsync(searchResults, {
         ...providedOptions,
         // Custom native modules are not filtered out
         // when they're not specified in package.json dependencies.
@@ -148,7 +148,7 @@ function resolvePackageNameAndVersion(packagePath, { fallbackToDirName } = {}) {
 /**
  * Filters out packages that are not the dependencies of the project.
  */
-function filterToProjectDependencies(results, options = {}) {
+async function filterToProjectDependenciesAsync(results, options) {
     const filteredResults = {};
     const visitedPackages = new Set();
     // iterate through always included package names and add them to the visited packages
@@ -201,7 +201,8 @@ function filterToProjectDependencies(results, options = {}) {
         }
     }
     // Visit project's package.
-    visitPackage(mergeLinkingOptions_1.projectPackageJsonPath);
+    const projectPackageJsonPath = await (0, mergeLinkingOptions_1.getProjectPackageJsonPathAsync)(options.projectRoot);
+    visitPackage(projectPackageJsonPath);
     return filteredResults;
 }
 //# sourceMappingURL=findModules.js.map
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/findModules.js.map b/node_modules/expo-modules-autolinking/build/autolinking/findModules.js.map
index 2bc104f..ea511a5 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/findModules.js.map
+++ b/node_modules/expo-modules-autolinking/build/autolinking/findModules.js.map
@@ -1 +1 @@
-{"version":3,"file":"findModules.js","sourceRoot":"","sources":["../../src/autolinking/findModules.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\n\nimport { requireAndResolveExpoModuleConfig } from '../ExpoModuleConfig';\nimport { PackageRevision, SearchOptions, SearchResults } from '../types';\nimport { mergeLinkingOptionsAsync, projectPackageJsonPath } from './mergeLinkingOptions';\n\n// Names of the config files. From lowest to highest priority.\nconst EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: Map<string, PackageRevision> = new Map();\n\n  const nativeModuleNames = new Set<string>();\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...options.searchPaths]\n      : options.searchPaths;\n\n  for (const searchPath of searchPaths) {\n    const isNativeModulesDir = searchPath === options.nativeModulesDir;\n\n    const packageConfigPaths = await findPackagesConfigPathsAsync(searchPath);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n\n      const { name, version } = resolvePackageNameAndVersion(packagePath, {\n        fallbackToDirName: isNativeModulesDir,\n      });\n\n      // we ignore the `exclude` option for custom native modules\n      if (\n        (!isNativeModulesDir && options.exclude?.includes(name)) ||\n        !expoModuleConfig.supportsPlatform(options.platform)\n      ) {\n        continue;\n      }\n\n      // add the current revision to the results\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n      addRevisionToResults(results, name, currentRevision);\n\n      // if the module is a native module, we need to add it to the nativeModuleNames set\n      if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n        nativeModuleNames.add(name);\n      }\n    }\n  }\n\n  const searchResults: SearchResults = Object.fromEntries(results.entries());\n\n  // It doesn't make much sense to strip modules if there is only one search path.\n  // (excluding custom native modules path)\n  // Workspace root usually doesn't specify all its dependencies (see Expo Go),\n  // so in this case we should link everything.\n  if (options.searchPaths.length <= 1) {\n    return searchResults;\n  }\n\n  return filterToProjectDependencies(searchResults, {\n    ...providedOptions,\n    // Custom native modules are not filtered out\n    // when they're not specified in package.json dependencies.\n    alwaysIncludedPackagesNames: nativeModuleNames,\n  });\n}\n\n/**\n * Returns the priority of the config at given path. Higher number means higher priority.\n */\nfunction configPriority(fullpath: string): number {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\n\n/**\n * Adds {@link revision} to the {@link results} map\n * or to package duplicates if it already exists.\n * @param results [mutable] yet resolved packages map\n * @param name resolved package name\n * @param revision resolved package revision\n */\nfunction addRevisionToResults(\n  results: Map<string, PackageRevision>,\n  name: string,\n  revision: PackageRevision\n): void {\n  if (!results.has(name)) {\n    // The revision that was found first will be the main one.\n    // An array of duplicates and the config are needed only here.\n    results.set(name, {\n      ...revision,\n      duplicates: [],\n    });\n  } else if (\n    results.get(name)?.path !== revision.path &&\n    results.get(name)?.duplicates?.every(({ path }) => path !== revision.path)\n  ) {\n    const { config, duplicates, ...duplicateEntry } = revision;\n    results.get(name)?.duplicates?.push(duplicateEntry);\n  }\n}\n\n/**\n * Returns paths to the highest priority config files, relative to the {@link searchPath}.\n * @example\n * ```\n * // Given the following file exists: /foo/myapp/modules/mymodule/expo-module.config.json\n * await findPackagesConfigPathsAsync('/foo/myapp/modules');\n * // returns ['mymodule/expo-module.config.json']\n *\n * await findPackagesConfigPathsAsync('/foo/myapp/modules/mymodule');\n * // returns ['expo-module.config.json']\n * ```\n */\nasync function findPackagesConfigPathsAsync(searchPath: string): Promise<string[]> {\n  const bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n  const paths = await glob(\n    [`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`],\n    {\n      cwd: searchPath,\n    }\n  );\n\n  // If the package has multiple configs (e.g. `unimodule.json` and `expo-module.config.json` during the transition time)\n  // then we want to give `expo-module.config.json` the priority.\n  return Object.values(\n    paths.reduce<Record<string, string>>((acc, configPath) => {\n      const dirname = path.dirname(configPath);\n\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {})\n  );\n}\n\n/**\n * Resolves package name and version for the given {@link packagePath} from its `package.json`.\n * if {@link fallbackToDirName} is true, it returns the dir name when `package.json` doesn't exist.\n * @returns object with `name` and `version` properties. `version` falls back to `UNVERSIONED` if cannot be resolved.\n */\nfunction resolvePackageNameAndVersion(\n  packagePath: string,\n  { fallbackToDirName }: { fallbackToDirName?: boolean } = {}\n): { name: string; version: string } {\n  try {\n    const { name, version } = require(path.join(packagePath, 'package.json'));\n    return { name, version: version || 'UNVERSIONED' };\n  } catch (e) {\n    if (fallbackToDirName) {\n      // we don't have the package.json name, so we'll use the directory name\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED',\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Filters out packages that are not the dependencies of the project.\n */\nfunction filterToProjectDependencies(\n  results: SearchResults,\n  options: Pick<SearchOptions, 'silent'> & { alwaysIncludedPackagesNames?: Set<string> } = {}\n) {\n  const filteredResults: SearchResults = {};\n  const visitedPackages = new Set<string>();\n\n  // iterate through always included package names and add them to the visited packages\n  // if the results contains them\n  for (const name of options.alwaysIncludedPackagesNames ?? []) {\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n\n  // Helper for traversing the dependency hierarchy.\n  function visitPackage(packageJsonPath: string) {\n    const packageJson = require(packageJsonPath);\n\n    // Prevent getting into the recursive loop.\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n\n    // Iterate over the dependencies to find transitive modules.\n    for (const dependencyName in packageJson.dependencies) {\n      const dependencyResult = results[dependencyName];\n\n      if (!filteredResults[dependencyName]) {\n        let dependencyPackageJsonPath: string;\n\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            /**\n             * Custom `require` that resolves from the current working dir instead of this script path.\n             * **Requires Node v12.2.0**\n             */\n            const projectRequire = createRequire(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error: any) {\n            // Some packages don't include package.json in its `exports` field,\n            // but none of our packages do that, so it seems fine to just ignore that type of error.\n            // Related issue: https://github.com/react-native-community/cli/issues/1168\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(\n                chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`)\n              );\n            }\n            continue;\n          }\n        }\n\n        // Visit the dependency package.\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n\n  // Visit project's package.\n  visitPackage(projectPackageJsonPath);\n\n  return filteredResults;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"findModules.js","sourceRoot":"","sources":["../../src/autolinking/findModules.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\n\nimport { requireAndResolveExpoModuleConfig } from '../ExpoModuleConfig';\nimport { PackageRevision, SearchOptions, SearchResults } from '../types';\nimport { getProjectPackageJsonPathAsync, mergeLinkingOptionsAsync } from './mergeLinkingOptions';\n\n// Names of the config files. From lowest to highest priority.\nconst EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: Map<string, PackageRevision> = new Map();\n\n  const nativeModuleNames = new Set<string>();\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...options.searchPaths]\n      : options.searchPaths;\n\n  for (const searchPath of searchPaths) {\n    const isNativeModulesDir = searchPath === options.nativeModulesDir;\n\n    const packageConfigPaths = await findPackagesConfigPathsAsync(searchPath);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n\n      const { name, version } = resolvePackageNameAndVersion(packagePath, {\n        fallbackToDirName: isNativeModulesDir,\n      });\n\n      // we ignore the `exclude` option for custom native modules\n      if (\n        (!isNativeModulesDir && options.exclude?.includes(name)) ||\n        !expoModuleConfig.supportsPlatform(options.platform)\n      ) {\n        continue;\n      }\n\n      // add the current revision to the results\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n      addRevisionToResults(results, name, currentRevision);\n\n      // if the module is a native module, we need to add it to the nativeModuleNames set\n      if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n        nativeModuleNames.add(name);\n      }\n    }\n  }\n\n  const searchResults: SearchResults = Object.fromEntries(results.entries());\n\n  // It doesn't make much sense to strip modules if there is only one search path.\n  // (excluding custom native modules path)\n  // Workspace root usually doesn't specify all its dependencies (see Expo Go),\n  // so in this case we should link everything.\n  if (options.searchPaths.length <= 1 || options.onlyProjectDeps === false) {\n    return searchResults;\n  }\n\n  return await filterToProjectDependenciesAsync(searchResults, {\n    ...providedOptions,\n    // Custom native modules are not filtered out\n    // when they're not specified in package.json dependencies.\n    alwaysIncludedPackagesNames: nativeModuleNames,\n  });\n}\n\n/**\n * Returns the priority of the config at given path. Higher number means higher priority.\n */\nfunction configPriority(fullpath: string): number {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\n\n/**\n * Adds {@link revision} to the {@link results} map\n * or to package duplicates if it already exists.\n * @param results [mutable] yet resolved packages map\n * @param name resolved package name\n * @param revision resolved package revision\n */\nfunction addRevisionToResults(\n  results: Map<string, PackageRevision>,\n  name: string,\n  revision: PackageRevision\n): void {\n  if (!results.has(name)) {\n    // The revision that was found first will be the main one.\n    // An array of duplicates and the config are needed only here.\n    results.set(name, {\n      ...revision,\n      duplicates: [],\n    });\n  } else if (\n    results.get(name)?.path !== revision.path &&\n    results.get(name)?.duplicates?.every(({ path }) => path !== revision.path)\n  ) {\n    const { config, duplicates, ...duplicateEntry } = revision;\n    results.get(name)?.duplicates?.push(duplicateEntry);\n  }\n}\n\n/**\n * Returns paths to the highest priority config files, relative to the {@link searchPath}.\n * @example\n * ```\n * // Given the following file exists: /foo/myapp/modules/mymodule/expo-module.config.json\n * await findPackagesConfigPathsAsync('/foo/myapp/modules');\n * // returns ['mymodule/expo-module.config.json']\n *\n * await findPackagesConfigPathsAsync('/foo/myapp/modules/mymodule');\n * // returns ['expo-module.config.json']\n * ```\n */\nasync function findPackagesConfigPathsAsync(searchPath: string): Promise<string[]> {\n  const bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n  const paths = await glob(\n    [`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`],\n    {\n      cwd: searchPath,\n    }\n  );\n\n  // If the package has multiple configs (e.g. `unimodule.json` and `expo-module.config.json` during the transition time)\n  // then we want to give `expo-module.config.json` the priority.\n  return Object.values(\n    paths.reduce<Record<string, string>>((acc, configPath) => {\n      const dirname = path.dirname(configPath);\n\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {})\n  );\n}\n\n/**\n * Resolves package name and version for the given {@link packagePath} from its `package.json`.\n * if {@link fallbackToDirName} is true, it returns the dir name when `package.json` doesn't exist.\n * @returns object with `name` and `version` properties. `version` falls back to `UNVERSIONED` if cannot be resolved.\n */\nfunction resolvePackageNameAndVersion(\n  packagePath: string,\n  { fallbackToDirName }: { fallbackToDirName?: boolean } = {}\n): { name: string; version: string } {\n  try {\n    const { name, version } = require(path.join(packagePath, 'package.json'));\n    return { name, version: version || 'UNVERSIONED' };\n  } catch (e) {\n    if (fallbackToDirName) {\n      // we don't have the package.json name, so we'll use the directory name\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED',\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Filters out packages that are not the dependencies of the project.\n */\nasync function filterToProjectDependenciesAsync(\n  results: SearchResults,\n  options: Pick<SearchOptions, 'projectRoot' | 'silent'> & {\n    alwaysIncludedPackagesNames?: Set<string>;\n  }\n): Promise<SearchResults> {\n  const filteredResults: SearchResults = {};\n  const visitedPackages = new Set<string>();\n\n  // iterate through always included package names and add them to the visited packages\n  // if the results contains them\n  for (const name of options.alwaysIncludedPackagesNames ?? []) {\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n\n  // Helper for traversing the dependency hierarchy.\n  function visitPackage(packageJsonPath: string) {\n    const packageJson = require(packageJsonPath);\n\n    // Prevent getting into the recursive loop.\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n\n    // Iterate over the dependencies to find transitive modules.\n    for (const dependencyName in packageJson.dependencies) {\n      const dependencyResult = results[dependencyName];\n\n      if (!filteredResults[dependencyName]) {\n        let dependencyPackageJsonPath: string;\n\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            /**\n             * Custom `require` that resolves from the current working dir instead of this script path.\n             * **Requires Node v12.2.0**\n             */\n            const projectRequire = createRequire(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error: any) {\n            // Some packages don't include package.json in its `exports` field,\n            // but none of our packages do that, so it seems fine to just ignore that type of error.\n            // Related issue: https://github.com/react-native-community/cli/issues/1168\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(\n                chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`)\n              );\n            }\n            continue;\n          }\n        }\n\n        // Visit the dependency package.\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n\n  // Visit project's package.\n  const projectPackageJsonPath = await getProjectPackageJsonPathAsync(options.projectRoot);\n  visitPackage(projectPackageJsonPath);\n\n  return filteredResults;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/index.d.ts b/node_modules/expo-modules-autolinking/build/autolinking/index.d.ts
index 6e31064..f1cffec 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/index.d.ts
+++ b/node_modules/expo-modules-autolinking/build/autolinking/index.d.ts
@@ -1,5 +1,12 @@
-export { findModulesAsync, } from './findModules';
-export { resolveSearchPathsAsync, mergeLinkingOptionsAsync, } from './mergeLinkingOptions';
+import { findModulesAsync } from './findModules';
+import { mergeLinkingOptionsAsync, resolveSearchPathsAsync } from './mergeLinkingOptions';
+import { resolveModulesAsync } from './resolveModules';
+import type { ModuleDescriptor, SearchOptions } from '../types';
+export { findModulesAsync, mergeLinkingOptionsAsync, resolveModulesAsync, resolveSearchPathsAsync };
 export { generatePackageListAsync } from './generatePackageList';
-export { resolveModulesAsync } from './resolveModules';
 export { verifySearchResults } from './verifySearchResults';
+export * from '../types';
+/**
+ * Programmatic API to query autolinked modules for a project.
+ */
+export declare function queryAutolinkingModulesFromProjectAsync(projectRoot: string, options: Pick<SearchOptions, 'platform' | 'exclude' | 'onlyProjectDeps'>): Promise<ModuleDescriptor[]>;
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/index.js b/node_modules/expo-modules-autolinking/build/autolinking/index.js
index 768dc8e..172cd47 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/index.js
+++ b/node_modules/expo-modules-autolinking/build/autolinking/index.js
@@ -1,17 +1,40 @@
 "use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.verifySearchResults = exports.resolveModulesAsync = exports.generatePackageListAsync = exports.mergeLinkingOptionsAsync = exports.resolveSearchPathsAsync = exports.findModulesAsync = void 0;
-var findModules_1 = require("./findModules");
-// NOTE(evanbacon): Used in @expo/prebuild-config
+exports.queryAutolinkingModulesFromProjectAsync = exports.verifySearchResults = exports.generatePackageListAsync = exports.resolveSearchPathsAsync = exports.resolveModulesAsync = exports.mergeLinkingOptionsAsync = exports.findModulesAsync = void 0;
+const findModules_1 = require("./findModules");
 Object.defineProperty(exports, "findModulesAsync", { enumerable: true, get: function () { return findModules_1.findModulesAsync; } });
-var mergeLinkingOptions_1 = require("./mergeLinkingOptions");
-// NOTE(evanbacon): Used in @expo/prebuild-config
-Object.defineProperty(exports, "resolveSearchPathsAsync", { enumerable: true, get: function () { return mergeLinkingOptions_1.resolveSearchPathsAsync; } });
+const mergeLinkingOptions_1 = require("./mergeLinkingOptions");
 Object.defineProperty(exports, "mergeLinkingOptionsAsync", { enumerable: true, get: function () { return mergeLinkingOptions_1.mergeLinkingOptionsAsync; } });
+Object.defineProperty(exports, "resolveSearchPathsAsync", { enumerable: true, get: function () { return mergeLinkingOptions_1.resolveSearchPathsAsync; } });
+const resolveModules_1 = require("./resolveModules");
+Object.defineProperty(exports, "resolveModulesAsync", { enumerable: true, get: function () { return resolveModules_1.resolveModulesAsync; } });
 var generatePackageList_1 = require("./generatePackageList");
 Object.defineProperty(exports, "generatePackageListAsync", { enumerable: true, get: function () { return generatePackageList_1.generatePackageListAsync; } });
-var resolveModules_1 = require("./resolveModules");
-Object.defineProperty(exports, "resolveModulesAsync", { enumerable: true, get: function () { return resolveModules_1.resolveModulesAsync; } });
 var verifySearchResults_1 = require("./verifySearchResults");
 Object.defineProperty(exports, "verifySearchResults", { enumerable: true, get: function () { return verifySearchResults_1.verifySearchResults; } });
+__exportStar(require("../types"), exports);
+/**
+ * Programmatic API to query autolinked modules for a project.
+ */
+async function queryAutolinkingModulesFromProjectAsync(projectRoot, options) {
+    const searchPaths = await (0, mergeLinkingOptions_1.resolveSearchPathsAsync)(null, projectRoot);
+    const linkOptions = await (0, mergeLinkingOptions_1.mergeLinkingOptionsAsync)({ ...options, projectRoot, searchPaths });
+    const searchResults = await (0, findModules_1.findModulesAsync)(linkOptions);
+    return await (0, resolveModules_1.resolveModulesAsync)(searchResults, linkOptions);
+}
+exports.queryAutolinkingModulesFromProjectAsync = queryAutolinkingModulesFromProjectAsync;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/index.js.map b/node_modules/expo-modules-autolinking/build/autolinking/index.js.map
index 9dc9b1a..454cb2d 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/index.js.map
+++ b/node_modules/expo-modules-autolinking/build/autolinking/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/autolinking/index.ts"],"names":[],"mappings":";;;AAAA,6CAGuB;AAFrB,iDAAiD;AACjD,+GAAA,gBAAgB,OAAA;AAElB,6DAI+B;AAH7B,iDAAiD;AACjD,8HAAA,uBAAuB,OAAA;AACvB,+HAAA,wBAAwB,OAAA;AAE1B,6DAAiE;AAAxD,+HAAA,wBAAwB,OAAA;AACjC,mDAAuD;AAA9C,qHAAA,mBAAmB,OAAA;AAC5B,6DAA4D;AAAnD,0HAAA,mBAAmB,OAAA","sourcesContent":["export {\n  // NOTE(evanbacon): Used in @expo/prebuild-config\n  findModulesAsync,\n} from './findModules';\nexport {\n  // NOTE(evanbacon): Used in @expo/prebuild-config\n  resolveSearchPathsAsync,\n  mergeLinkingOptionsAsync,\n} from './mergeLinkingOptions';\nexport { generatePackageListAsync } from './generatePackageList';\nexport { resolveModulesAsync } from './resolveModules';\nexport { verifySearchResults } from './verifySearchResults';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/autolinking/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,+CAAiD;AAKxC,iGALA,8BAAgB,OAKA;AAJzB,+DAA0F;AAI/D,yGAJlB,8CAAwB,OAIkB;AAAuB,wGAJvC,6CAAuB,OAIuC;AAHjG,qDAAuD;AAGF,oGAH5C,oCAAmB,OAG4C;AACxE,6DAAiE;AAAxD,+HAAA,wBAAwB,OAAA;AACjC,6DAA4D;AAAnD,0HAAA,mBAAmB,OAAA;AAC5B,2CAAyB;AAEzB;;GAEG;AACI,KAAK,UAAU,uCAAuC,CAC3D,WAAmB,EACnB,OAAwE;IAExE,MAAM,WAAW,GAAG,MAAM,IAAA,6CAAuB,EAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IACrE,MAAM,WAAW,GAAG,MAAM,IAAA,8CAAwB,EAAC,EAAE,GAAG,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,CAAC,CAAC;IAC7F,MAAM,aAAa,GAAG,MAAM,IAAA,8BAAgB,EAAC,WAAW,CAAC,CAAC;IAC1D,OAAO,MAAM,IAAA,oCAAmB,EAAC,aAAa,EAAE,WAAW,CAAC,CAAC;AAC/D,CAAC;AARD,0FAQC","sourcesContent":["import { findModulesAsync } from './findModules';\nimport { mergeLinkingOptionsAsync, resolveSearchPathsAsync } from './mergeLinkingOptions';\nimport { resolveModulesAsync } from './resolveModules';\nimport type { ModuleDescriptor, SearchOptions } from '../types';\n\nexport { findModulesAsync, mergeLinkingOptionsAsync, resolveModulesAsync, resolveSearchPathsAsync };\nexport { generatePackageListAsync } from './generatePackageList';\nexport { verifySearchResults } from './verifySearchResults';\nexport * from '../types';\n\n/**\n * Programmatic API to query autolinked modules for a project.\n */\nexport async function queryAutolinkingModulesFromProjectAsync(\n  projectRoot: string,\n  options: Pick<SearchOptions, 'platform' | 'exclude' | 'onlyProjectDeps'>\n): Promise<ModuleDescriptor[]> {\n  const searchPaths = await resolveSearchPathsAsync(null, projectRoot);\n  const linkOptions = await mergeLinkingOptionsAsync({ ...options, projectRoot, searchPaths });\n  const searchResults = await findModulesAsync(linkOptions);\n  return await resolveModulesAsync(searchResults, linkOptions);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.d.ts b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.d.ts
index 7952995..0e0079a 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.d.ts
+++ b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.d.ts
@@ -1,8 +1,8 @@
 import { SearchOptions } from '../types';
 /**
- * Path to the `package.json` of the closest project in the current working dir.
+ * Find the path to the `package.json` of the closest project in the given project root.
  */
-export declare const projectPackageJsonPath: string;
+export declare function getProjectPackageJsonPathAsync(projectRoot: string): Promise<string>;
 /**
  * Merges autolinking options from different sources (the later the higher priority)
  * - options defined in package.json's `expo.autolinking` field
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js
index ea57f10..f617989 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js
+++ b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js
@@ -3,18 +3,21 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.resolveSearchPathsAsync = exports.mergeLinkingOptionsAsync = exports.projectPackageJsonPath = void 0;
+exports.resolveSearchPathsAsync = exports.mergeLinkingOptionsAsync = exports.getProjectPackageJsonPathAsync = void 0;
 const find_up_1 = __importDefault(require("find-up"));
 const fs_extra_1 = __importDefault(require("fs-extra"));
 const path_1 = __importDefault(require("path"));
 /**
- * Path to the `package.json` of the closest project in the current working dir.
+ * Find the path to the `package.json` of the closest project in the given project root.
  */
-exports.projectPackageJsonPath = find_up_1.default.sync('package.json', { cwd: process.cwd() });
-// This won't happen in usual scenarios, but we need to unwrap the optional path :)
-if (!exports.projectPackageJsonPath) {
-    throw new Error(`Couldn't find "package.json" up from path "${process.cwd()}"`);
+async function getProjectPackageJsonPathAsync(projectRoot) {
+    const result = await (0, find_up_1.default)('package.json', { cwd: projectRoot });
+    if (!result) {
+        throw new Error(`Couldn't find "package.json" up from path "${projectRoot}"`);
+    }
+    return result;
 }
+exports.getProjectPackageJsonPathAsync = getProjectPackageJsonPathAsync;
 /**
  * Merges autolinking options from different sources (the later the higher priority)
  * - options defined in package.json's `expo.autolinking` field
@@ -22,13 +25,13 @@ if (!exports.projectPackageJsonPath) {
  * - options provided to the CLI command
  */
 async function mergeLinkingOptionsAsync(providedOptions) {
-    const packageJson = require(exports.projectPackageJsonPath);
+    const packageJson = require(await getProjectPackageJsonPathAsync(providedOptions.projectRoot));
     const baseOptions = packageJson.expo?.autolinking;
     const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];
     const finalOptions = Object.assign({}, baseOptions, platformOptions, providedOptions);
     // Makes provided paths absolute or falls back to default paths if none was provided.
-    finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());
-    finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(finalOptions.nativeModulesDir, process.cwd());
+    finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, providedOptions.projectRoot);
+    finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(finalOptions.nativeModulesDir, providedOptions.projectRoot);
     return finalOptions;
 }
 exports.mergeLinkingOptionsAsync = mergeLinkingOptionsAsync;
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js.map b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js.map
index ec538df..f4c8ce1 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js.map
+++ b/node_modules/expo-modules-autolinking/build/autolinking/mergeLinkingOptions.js.map
@@ -1 +1 @@
-{"version":3,"file":"mergeLinkingOptions.js","sourceRoot":"","sources":["../../src/autolinking/mergeLinkingOptions.ts"],"names":[],"mappings":"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","sourcesContent":["import findUp from 'find-up';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { SearchOptions } from '../types';\n\n/**\n * Path to the `package.json` of the closest project in the current working dir.\n */\nexport const projectPackageJsonPath = findUp.sync('package.json', { cwd: process.cwd() }) as string;\n\n// This won't happen in usual scenarios, but we need to unwrap the optional path :)\nif (!projectPackageJsonPath) {\n  throw new Error(`Couldn't find \"package.json\" up from path \"${process.cwd()}\"`);\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expo.autolinking` field\n * - platform-specific options from the above (e.g. `expo.autolinking.ios`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  const packageJson = require(projectPackageJsonPath);\n  const baseOptions = packageJson.expo?.autolinking;\n  const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];\n  const finalOptions = Object.assign(\n    {},\n    baseOptions,\n    platformOptions,\n    providedOptions\n  ) as OptionsType;\n\n  // Makes provided paths absolute or falls back to default paths if none was provided.\n  finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());\n\n  finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(\n    finalOptions.nativeModulesDir,\n    process.cwd()\n  );\n\n  return finalOptions;\n}\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport async function resolveSearchPathsAsync(\n  searchPaths: string[] | null,\n  cwd: string\n): Promise<string[]> {\n  return searchPaths && searchPaths.length > 0\n    ? searchPaths.map((searchPath) => path.resolve(cwd, searchPath))\n    : await findDefaultPathsAsync(cwd);\n}\n\n/**\n * Looks up for workspace's `node_modules` paths.\n */\nasync function findDefaultPathsAsync(cwd: string): Promise<string[]> {\n  const paths = [];\n  let dir = cwd;\n  let pkgJsonPath: string | undefined;\n\n  while ((pkgJsonPath = await findUp('package.json', { cwd: dir }))) {\n    dir = path.dirname(path.dirname(pkgJsonPath));\n    paths.push(path.join(pkgJsonPath, '..', 'node_modules'));\n\n    // This stops the infinite loop when the package.json is placed at the root dir.\n    if (path.dirname(dir) === dir) {\n      break;\n    }\n  }\n  return paths;\n}\n\n/**\n * Finds the real path to custom native modules directory.\n * - When {@link cwd} is inside the project directory, the path is searched relatively\n * to the project root (directory with the `package.json` file).\n * - When {@link cwd} is outside project directory (no `package.json` found), it is relative to\n * the current working directory (the {@link cwd} param).\n *\n * @param nativeModulesDir path to custom native modules directory. Defaults to `\"./modules\"` if null.\n * @param cwd current working directory\n * @returns resolved native modules directory or `null` if it is not found or doesn't exist.\n */\nasync function resolveNativeModulesDirAsync(\n  nativeModulesDir: string | null | undefined,\n  cwd: string\n): Promise<string | null> {\n  const packageJsonPath = await findUp('package.json', { cwd });\n  const projectRoot = packageJsonPath != null ? path.join(packageJsonPath, '..') : cwd;\n  const resolvedPath = path.resolve(projectRoot, nativeModulesDir || 'modules');\n  return fs.existsSync(resolvedPath) ? resolvedPath : null;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"mergeLinkingOptions.js","sourceRoot":"","sources":["../../src/autolinking/mergeLinkingOptions.ts"],"names":[],"mappings":"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","sourcesContent":["import findUp from 'find-up';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { SearchOptions } from '../types';\n\n/**\n * Find the path to the `package.json` of the closest project in the given project root.\n */\nexport async function getProjectPackageJsonPathAsync(projectRoot: string): Promise<string> {\n  const result = await findUp('package.json', { cwd: projectRoot });\n  if (!result) {\n    throw new Error(`Couldn't find \"package.json\" up from path \"${projectRoot}\"`);\n  }\n  return result;\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expo.autolinking` field\n * - platform-specific options from the above (e.g. `expo.autolinking.ios`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  const packageJson = require(await getProjectPackageJsonPathAsync(providedOptions.projectRoot));\n  const baseOptions = packageJson.expo?.autolinking;\n  const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];\n  const finalOptions = Object.assign(\n    {},\n    baseOptions,\n    platformOptions,\n    providedOptions\n  ) as OptionsType;\n\n  // Makes provided paths absolute or falls back to default paths if none was provided.\n  finalOptions.searchPaths = await resolveSearchPathsAsync(\n    finalOptions.searchPaths,\n    providedOptions.projectRoot\n  );\n\n  finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(\n    finalOptions.nativeModulesDir,\n    providedOptions.projectRoot\n  );\n\n  return finalOptions;\n}\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport async function resolveSearchPathsAsync(\n  searchPaths: string[] | null,\n  cwd: string\n): Promise<string[]> {\n  return searchPaths && searchPaths.length > 0\n    ? searchPaths.map((searchPath) => path.resolve(cwd, searchPath))\n    : await findDefaultPathsAsync(cwd);\n}\n\n/**\n * Looks up for workspace's `node_modules` paths.\n */\nasync function findDefaultPathsAsync(cwd: string): Promise<string[]> {\n  const paths = [];\n  let dir = cwd;\n  let pkgJsonPath: string | undefined;\n\n  while ((pkgJsonPath = await findUp('package.json', { cwd: dir }))) {\n    dir = path.dirname(path.dirname(pkgJsonPath));\n    paths.push(path.join(pkgJsonPath, '..', 'node_modules'));\n\n    // This stops the infinite loop when the package.json is placed at the root dir.\n    if (path.dirname(dir) === dir) {\n      break;\n    }\n  }\n  return paths;\n}\n\n/**\n * Finds the real path to custom native modules directory.\n * - When {@link cwd} is inside the project directory, the path is searched relatively\n * to the project root (directory with the `package.json` file).\n * - When {@link cwd} is outside project directory (no `package.json` found), it is relative to\n * the current working directory (the {@link cwd} param).\n *\n * @param nativeModulesDir path to custom native modules directory. Defaults to `\"./modules\"` if null.\n * @param cwd current working directory\n * @returns resolved native modules directory or `null` if it is not found or doesn't exist.\n */\nasync function resolveNativeModulesDirAsync(\n  nativeModulesDir: string | null | undefined,\n  cwd: string\n): Promise<string | null> {\n  const packageJsonPath = await findUp('package.json', { cwd });\n  const projectRoot = packageJsonPath != null ? path.join(packageJsonPath, '..') : cwd;\n  const resolvedPath = path.resolve(projectRoot, nativeModulesDir || 'modules');\n  return fs.existsSync(resolvedPath) ? resolvedPath : null;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.d.ts b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.d.ts
index fa3223a..e8931a2 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.d.ts
+++ b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.d.ts
@@ -1,5 +1,5 @@
-import { SearchResults } from '../types';
+import { SearchOptions, SearchResults } from '../types';
 /**
  * Verifies the search results by checking whether there are no duplicates.
  */
-export declare function verifySearchResults(searchResults: SearchResults): number;
+export declare function verifySearchResults(searchResults: SearchResults, options: SearchOptions): number;
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js
index 8660259..e9a74ba 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js
+++ b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js
@@ -9,9 +9,8 @@ const path_1 = __importDefault(require("path"));
 /**
  * Verifies the search results by checking whether there are no duplicates.
  */
-function verifySearchResults(searchResults) {
-    const cwd = process.cwd();
-    const relativePath = (pkg) => path_1.default.relative(cwd, pkg.path);
+function verifySearchResults(searchResults, options) {
+    const relativePath = (pkg) => path_1.default.relative(options.projectRoot, pkg.path);
     let counter = 0;
     for (const moduleName in searchResults) {
         const revision = searchResults[moduleName];
diff --git a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js.map b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js.map
index ef0f407..548ec6b 100644
--- a/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js.map
+++ b/node_modules/expo-modules-autolinking/build/autolinking/verifySearchResults.js.map
@@ -1 +1 @@
-{"version":3,"file":"verifySearchResults.js","sourceRoot":"","sources":["../../src/autolinking/verifySearchResults.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAC1B,gDAAwB;AAIxB;;GAEG;AACH,SAAgB,mBAAmB,CAAC,aAA4B;IAC9D,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;IAC1B,MAAM,YAAY,GAAqC,CAAC,GAAG,EAAE,EAAE,CAAC,cAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;IAC7F,IAAI,OAAO,GAAG,CAAC,CAAC;IAEhB,KAAK,MAAM,UAAU,IAAI,aAAa,EAAE;QACtC,MAAM,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC;QAE3C,IAAI,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE;YAC/B,OAAO,CAAC,IAAI,CAAC,mCAAmC,eAAK,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;YAC3E,OAAO,CAAC,GAAG,CAAC,MAAM,eAAK,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,KAAK,eAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE7F,KAAK,MAAM,SAAS,IAAI,QAAQ,CAAC,UAAU,EAAE;gBAC3C,OAAO,CAAC,GAAG,CAAC,MAAM,eAAK,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,KAAK,eAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;aAC7F;YACD,OAAO,EAAE,CAAC;SACX;KACF;IACD,IAAI,OAAO,GAAG,CAAC,EAAE;QACf,OAAO,CAAC,IAAI,CACV,wGAAwG,CACzG,CAAC;KACH;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAxBD,kDAwBC","sourcesContent":["import chalk from 'chalk';\nimport path from 'path';\n\nimport { PackageRevision, SearchResults } from '../types';\n\n/**\n * Verifies the search results by checking whether there are no duplicates.\n */\nexport function verifySearchResults(searchResults: SearchResults): number {\n  const cwd = process.cwd();\n  const relativePath: (pkg: PackageRevision) => string = (pkg) => path.relative(cwd, pkg.path);\n  let counter = 0;\n\n  for (const moduleName in searchResults) {\n    const revision = searchResults[moduleName];\n\n    if (revision.duplicates?.length) {\n      console.warn(`⚠️  Found multiple revisions of ${chalk.green(moduleName)}`);\n      console.log(` - ${chalk.magenta(relativePath(revision))} (${chalk.cyan(revision.version)})`);\n\n      for (const duplicate of revision.duplicates) {\n        console.log(` - ${chalk.gray(relativePath(duplicate))} (${chalk.gray(duplicate.version)})`);\n      }\n      counter++;\n    }\n  }\n  if (counter > 0) {\n    console.warn(\n      '⚠️  Please get rid of multiple revisions as it may introduce some side effects or compatibility issues'\n    );\n  }\n  return counter;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"verifySearchResults.js","sourceRoot":"","sources":["../../src/autolinking/verifySearchResults.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAC1B,gDAAwB;AAIxB;;GAEG;AACH,SAAgB,mBAAmB,CAAC,aAA4B,EAAE,OAAsB;IACtF,MAAM,YAAY,GAAqC,CAAC,GAAG,EAAE,EAAE,CAC7D,cAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/C,IAAI,OAAO,GAAG,CAAC,CAAC;IAEhB,KAAK,MAAM,UAAU,IAAI,aAAa,EAAE;QACtC,MAAM,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC;QAE3C,IAAI,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE;YAC/B,OAAO,CAAC,IAAI,CAAC,mCAAmC,eAAK,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;YAC3E,OAAO,CAAC,GAAG,CAAC,MAAM,eAAK,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,KAAK,eAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE7F,KAAK,MAAM,SAAS,IAAI,QAAQ,CAAC,UAAU,EAAE;gBAC3C,OAAO,CAAC,GAAG,CAAC,MAAM,eAAK,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,KAAK,eAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;aAC7F;YACD,OAAO,EAAE,CAAC;SACX;KACF;IACD,IAAI,OAAO,GAAG,CAAC,EAAE;QACf,OAAO,CAAC,IAAI,CACV,wGAAwG,CACzG,CAAC;KACH;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAxBD,kDAwBC","sourcesContent":["import chalk from 'chalk';\nimport path from 'path';\n\nimport { PackageRevision, SearchOptions, SearchResults } from '../types';\n\n/**\n * Verifies the search results by checking whether there are no duplicates.\n */\nexport function verifySearchResults(searchResults: SearchResults, options: SearchOptions): number {\n  const relativePath: (pkg: PackageRevision) => string = (pkg) =>\n    path.relative(options.projectRoot, pkg.path);\n  let counter = 0;\n\n  for (const moduleName in searchResults) {\n    const revision = searchResults[moduleName];\n\n    if (revision.duplicates?.length) {\n      console.warn(`⚠️  Found multiple revisions of ${chalk.green(moduleName)}`);\n      console.log(` - ${chalk.magenta(relativePath(revision))} (${chalk.cyan(revision.version)})`);\n\n      for (const duplicate of revision.duplicates) {\n        console.log(` - ${chalk.gray(relativePath(duplicate))} (${chalk.gray(duplicate.version)})`);\n      }\n      counter++;\n    }\n  }\n  if (counter > 0) {\n    console.warn(\n      '⚠️  Please get rid of multiple revisions as it may introduce some side effects or compatibility issues'\n    );\n  }\n  return counter;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/index.js b/node_modules/expo-modules-autolinking/build/index.js
index afa28b1..03fc5bc 100644
--- a/node_modules/expo-modules-autolinking/build/index.js
+++ b/node_modules/expo-modules-autolinking/build/index.js
@@ -17,6 +17,9 @@ function registerSearchCommand(commandName, fn) {
         .option('-e, --exclude <exclude...>', 'Package names to exclude when looking up for modules.', (value, previous) => (previous ?? []).concat(value))
         .option('-p, --platform [platform]', 'The platform that the resulting modules must support. Available options: "ios", "android"', 'ios')
         .option('--silent', 'Silence resolution warnings')
+        .addOption(new commander_1.default.Option('--project-root <projectRoot>', 'The path to the root of the project').default(process.cwd(), 'process.cwd()'))
+        .option('--only-project-deps', 'For a monorepo, include all modules even if they are not in the project dependencies.', true)
+        .option('--no-only-project-deps', 'Opposite of --only-project-deps', false)
         .action(async (searchPaths, providedOptions) => {
         const options = await (0, autolinking_1.mergeLinkingOptionsAsync)({
             ...providedOptions,
@@ -51,8 +54,8 @@ module.exports = async function (args) {
         }
     }).option('-j, --json', 'Output results in the plain JSON format.', () => true, false);
     // Checks whether there are no resolving issues in the current setup.
-    registerSearchCommand('verify', (results) => {
-        const numberOfDuplicates = (0, autolinking_1.verifySearchResults)(results);
+    registerSearchCommand('verify', (results, options) => {
+        const numberOfDuplicates = (0, autolinking_1.verifySearchResults)(results, options);
         if (!numberOfDuplicates) {
             console.log('✅ Everything is fine!');
         }
@@ -60,7 +63,7 @@ module.exports = async function (args) {
     // Searches for available expo modules and resolves the results for given platform.
     registerResolveCommand('resolve', async (results, options) => {
         const modules = await (0, autolinking_1.resolveModulesAsync)(results, options);
-        const extraDependencies = await (0, extraDependencies_1.resolveExtraDependenciesAsync)();
+        const extraDependencies = await (0, extraDependencies_1.resolveExtraDependenciesAsync)(options.projectRoot);
         if (options.json) {
             console.log(JSON.stringify({ extraDependencies, modules }));
         }
diff --git a/node_modules/expo-modules-autolinking/build/index.js.map b/node_modules/expo-modules-autolinking/build/index.js.map
index 4676e6e..1bad172 100644
--- a/node_modules/expo-modules-autolinking/build/index.js.map
+++ b/node_modules/expo-modules-autolinking/build/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import commander from 'commander';\n\nimport { patchReactImportsAsync } from './ReactImportsPatcher';\nimport {\n  findModulesAsync,\n  resolveModulesAsync,\n  verifySearchResults,\n  generatePackageListAsync,\n  mergeLinkingOptionsAsync,\n} from './autolinking';\nimport { resolveExtraDependenciesAsync } from './autolinking/extraDependencies';\nimport { GenerateOptions, ResolveOptions, SearchOptions, SearchResults } from './types';\n\n/**\n * Registers a command that only searches for available expo modules.\n */\nfunction registerSearchCommand<OptionsType extends SearchOptions>(\n  commandName: string,\n  fn: (search: SearchResults, options: OptionsType) => any\n) {\n  return commander\n    .command(`${commandName} [paths...]`)\n    .option<string[] | null>(\n      '-i, --ignore-paths <ignorePaths...>',\n      'Paths to ignore when looking up for modules.',\n      (value, previous) => (previous ?? []).concat(value)\n    )\n    .option<string[] | null>(\n      '-e, --exclude <exclude...>',\n      'Package names to exclude when looking up for modules.',\n      (value, previous) => (previous ?? []).concat(value)\n    )\n    .option(\n      '-p, --platform [platform]',\n      'The platform that the resulting modules must support. Available options: \"ios\", \"android\"',\n      'ios'\n    )\n    .option('--silent', 'Silence resolution warnings')\n    .action(async (searchPaths, providedOptions) => {\n      const options = await mergeLinkingOptionsAsync<OptionsType>({\n        ...providedOptions,\n        searchPaths,\n      });\n      const searchResults = await findModulesAsync(options);\n      return await fn(searchResults, options);\n    });\n}\n\n/**\n * Registers a command that searches for modules and then resolves them for specific platform.\n */\nfunction registerResolveCommand<OptionsType extends ResolveOptions>(\n  commandName: string,\n  fn: (search: SearchResults, options: OptionsType) => any\n) {\n  return registerSearchCommand<OptionsType>(commandName, fn);\n}\n\n// Register for `patch-react-imports` command\nfunction registerPatchReactImportsCommand() {\n  return commander\n    .command('patch-react-imports [paths...]')\n    .requiredOption('--pods-root <podsRoot>', 'The path to `Pods` directory')\n    .option('--dry-run', 'Only list files without writing changes to the file system')\n    .action(patchReactImportsAsync);\n}\n\nmodule.exports = async function (args: string[]) {\n  // Searches for available expo modules.\n  registerSearchCommand<SearchOptions & { json?: boolean }>('search', async (results, options) => {\n    if (options.json) {\n      console.log(JSON.stringify(results));\n    } else {\n      console.log(require('util').inspect(results, false, null, true));\n    }\n  }).option<boolean>('-j, --json', 'Output results in the plain JSON format.', () => true, false);\n\n  // Checks whether there are no resolving issues in the current setup.\n  registerSearchCommand('verify', (results) => {\n    const numberOfDuplicates = verifySearchResults(results);\n    if (!numberOfDuplicates) {\n      console.log('✅ Everything is fine!');\n    }\n  });\n\n  // Searches for available expo modules and resolves the results for given platform.\n  registerResolveCommand('resolve', async (results, options) => {\n    const modules = await resolveModulesAsync(results, options);\n    const extraDependencies = await resolveExtraDependenciesAsync();\n\n    if (options.json) {\n      console.log(JSON.stringify({ extraDependencies, modules }));\n    } else {\n      console.log(require('util').inspect({ extraDependencies, modules }, false, null, true));\n    }\n  }).option<boolean>('-j, --json', 'Output results in the plain JSON format.', () => true, false);\n\n  // Generates a source file listing all packages to link.\n  registerResolveCommand<GenerateOptions>('generate-package-list', async (results, options) => {\n    const modules = options.empty ? [] : await resolveModulesAsync(results, options);\n    generatePackageListAsync(modules, options);\n  })\n    .option(\n      '-t, --target <path>',\n      'Path to the target file, where the package list should be written to.'\n    )\n    .option(\n      '-n, --namespace <namespace>',\n      'Java package name under which the package list should be placed.'\n    )\n    .option(\n      '--empty',\n      'Whether to only generate an empty list. Might be used when the user opts-out of autolinking.',\n      false\n    );\n\n  registerPatchReactImportsCommand();\n\n  await commander\n    .version(require('expo-modules-autolinking/package.json').version)\n    .description('CLI command that searches for Expo modules to autolink them.')\n    .parseAsync(args, { from: 'user' });\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import commander from 'commander';\n\nimport { patchReactImportsAsync } from './ReactImportsPatcher';\nimport {\n  findModulesAsync,\n  resolveModulesAsync,\n  verifySearchResults,\n  generatePackageListAsync,\n  mergeLinkingOptionsAsync,\n} from './autolinking';\nimport { resolveExtraDependenciesAsync } from './autolinking/extraDependencies';\nimport { GenerateOptions, ResolveOptions, SearchOptions, SearchResults } from './types';\n\n/**\n * Registers a command that only searches for available expo modules.\n */\nfunction registerSearchCommand<OptionsType extends SearchOptions>(\n  commandName: string,\n  fn: (search: SearchResults, options: OptionsType) => any\n) {\n  return commander\n    .command(`${commandName} [paths...]`)\n    .option<string[] | null>(\n      '-i, --ignore-paths <ignorePaths...>',\n      'Paths to ignore when looking up for modules.',\n      (value, previous) => (previous ?? []).concat(value)\n    )\n    .option<string[] | null>(\n      '-e, --exclude <exclude...>',\n      'Package names to exclude when looking up for modules.',\n      (value, previous) => (previous ?? []).concat(value)\n    )\n    .option(\n      '-p, --platform [platform]',\n      'The platform that the resulting modules must support. Available options: \"ios\", \"android\"',\n      'ios'\n    )\n    .option('--silent', 'Silence resolution warnings')\n    .addOption(\n      new commander.Option(\n        '--project-root <projectRoot>',\n        'The path to the root of the project'\n      ).default(process.cwd(), 'process.cwd()')\n    )\n    .option(\n      '--only-project-deps',\n      'For a monorepo, include all modules even if they are not in the project dependencies.',\n      true\n    )\n    .option('--no-only-project-deps', 'Opposite of --only-project-deps', false)\n    .action(async (searchPaths, providedOptions) => {\n      const options = await mergeLinkingOptionsAsync<OptionsType>({\n        ...providedOptions,\n        searchPaths,\n      });\n      const searchResults = await findModulesAsync(options);\n      return await fn(searchResults, options);\n    });\n}\n\n/**\n * Registers a command that searches for modules and then resolves them for specific platform.\n */\nfunction registerResolveCommand<OptionsType extends ResolveOptions>(\n  commandName: string,\n  fn: (search: SearchResults, options: OptionsType) => any\n) {\n  return registerSearchCommand<OptionsType>(commandName, fn);\n}\n\n// Register for `patch-react-imports` command\nfunction registerPatchReactImportsCommand() {\n  return commander\n    .command('patch-react-imports [paths...]')\n    .requiredOption('--pods-root <podsRoot>', 'The path to `Pods` directory')\n    .option('--dry-run', 'Only list files without writing changes to the file system')\n    .action(patchReactImportsAsync);\n}\n\nmodule.exports = async function (args: string[]) {\n  // Searches for available expo modules.\n  registerSearchCommand<SearchOptions & { json?: boolean }>('search', async (results, options) => {\n    if (options.json) {\n      console.log(JSON.stringify(results));\n    } else {\n      console.log(require('util').inspect(results, false, null, true));\n    }\n  }).option<boolean>('-j, --json', 'Output results in the plain JSON format.', () => true, false);\n\n  // Checks whether there are no resolving issues in the current setup.\n  registerSearchCommand('verify', (results, options) => {\n    const numberOfDuplicates = verifySearchResults(results, options);\n    if (!numberOfDuplicates) {\n      console.log('✅ Everything is fine!');\n    }\n  });\n\n  // Searches for available expo modules and resolves the results for given platform.\n  registerResolveCommand('resolve', async (results, options) => {\n    const modules = await resolveModulesAsync(results, options);\n    const extraDependencies = await resolveExtraDependenciesAsync(options.projectRoot);\n\n    if (options.json) {\n      console.log(JSON.stringify({ extraDependencies, modules }));\n    } else {\n      console.log(require('util').inspect({ extraDependencies, modules }, false, null, true));\n    }\n  }).option<boolean>('-j, --json', 'Output results in the plain JSON format.', () => true, false);\n\n  // Generates a source file listing all packages to link.\n  registerResolveCommand<GenerateOptions>('generate-package-list', async (results, options) => {\n    const modules = options.empty ? [] : await resolveModulesAsync(results, options);\n    generatePackageListAsync(modules, options);\n  })\n    .option(\n      '-t, --target <path>',\n      'Path to the target file, where the package list should be written to.'\n    )\n    .option(\n      '-n, --namespace <namespace>',\n      'Java package name under which the package list should be placed.'\n    )\n    .option(\n      '--empty',\n      'Whether to only generate an empty list. Might be used when the user opts-out of autolinking.',\n      false\n    );\n\n  registerPatchReactImportsCommand();\n\n  await commander\n    .version(require('expo-modules-autolinking/package.json').version)\n    .description('CLI command that searches for Expo modules to autolink them.')\n    .parseAsync(args, { from: 'user' });\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/platforms/devtools.d.ts b/node_modules/expo-modules-autolinking/build/platforms/devtools.d.ts
new file mode 100644
index 0000000..61cbf34
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/build/platforms/devtools.d.ts
@@ -0,0 +1,2 @@
+import { ModuleDescriptorDevTools, PackageRevision } from '../types';
+export declare function resolveModuleAsync(packageName: string, revision: PackageRevision): Promise<ModuleDescriptorDevTools | null>;
diff --git a/node_modules/expo-modules-autolinking/build/platforms/devtools.js b/node_modules/expo-modules-autolinking/build/platforms/devtools.js
new file mode 100644
index 0000000..68bcb4e
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/build/platforms/devtools.js
@@ -0,0 +1,20 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.resolveModuleAsync = void 0;
+const path_1 = __importDefault(require("path"));
+async function resolveModuleAsync(packageName, revision) {
+    const devtoolsConfig = revision.config?.toJSON().devtools;
+    if (devtoolsConfig == null) {
+        return null;
+    }
+    return {
+        packageName,
+        packageRoot: revision.path,
+        webpageRoot: path_1.default.join(revision.path, devtoolsConfig.webpageRoot),
+    };
+}
+exports.resolveModuleAsync = resolveModuleAsync;
+//# sourceMappingURL=devtools.js.map
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/platforms/devtools.js.map b/node_modules/expo-modules-autolinking/build/platforms/devtools.js.map
new file mode 100644
index 0000000..252bfdf
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/build/platforms/devtools.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"devtools.js","sourceRoot":"","sources":["../../src/platforms/devtools.ts"],"names":[],"mappings":";;;;;;AAAA,gDAAwB;AAIjB,KAAK,UAAU,kBAAkB,CACtC,WAAmB,EACnB,QAAyB;IAEzB,MAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC;IAC1D,IAAI,cAAc,IAAI,IAAI,EAAE;QAC1B,OAAO,IAAI,CAAC;KACb;IAED,OAAO;QACL,WAAW;QACX,WAAW,EAAE,QAAQ,CAAC,IAAI;QAC1B,WAAW,EAAE,cAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,cAAc,CAAC,WAAW,CAAC;KAClE,CAAC;AACJ,CAAC;AAdD,gDAcC","sourcesContent":["import path from 'path';\n\nimport { ModuleDescriptorDevTools, PackageRevision } from '../types';\n\nexport async function resolveModuleAsync(\n  packageName: string,\n  revision: PackageRevision\n): Promise<ModuleDescriptorDevTools | null> {\n  const devtoolsConfig = revision.config?.toJSON().devtools;\n  if (devtoolsConfig == null) {\n    return null;\n  }\n\n  return {\n    packageName,\n    packageRoot: revision.path,\n    webpageRoot: path.join(revision.path, devtoolsConfig.webpageRoot),\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/build/types.d.ts b/node_modules/expo-modules-autolinking/build/types.d.ts
index 2ce78e2..734175d 100644
--- a/node_modules/expo-modules-autolinking/build/types.d.ts
+++ b/node_modules/expo-modules-autolinking/build/types.d.ts
@@ -1,5 +1,5 @@
 import { ExpoModuleConfig } from './ExpoModuleConfig';
-export type SupportedPlatform = 'ios' | 'android' | 'web';
+export type SupportedPlatform = 'ios' | 'android' | 'web' | 'devtools';
 export interface SearchOptions {
     searchPaths: string[];
     ignorePaths?: string[] | null;
@@ -7,6 +7,13 @@ export interface SearchOptions {
     platform: SupportedPlatform;
     silent?: boolean;
     nativeModulesDir?: string | null;
+    projectRoot: string;
+    /**
+     * Filter the search results to only include the project dependencies.
+     * In a monorepo, you may like to set this to false and link all modules from the monorepo.
+     * @default true
+     */
+    onlyProjectDeps?: boolean;
     flags?: Record<string, any>;
 }
 export interface ResolveOptions extends SearchOptions {
@@ -58,7 +65,12 @@ export interface ModuleDescriptorIos {
     reactDelegateHandlers: string[];
     debugOnly: boolean;
 }
-export type ModuleDescriptor = ModuleDescriptorAndroid | ModuleDescriptorIos;
+export interface ModuleDescriptorDevTools {
+    packageName: string;
+    packageRoot: string;
+    webpageRoot: string;
+}
+export type ModuleDescriptor = ModuleDescriptorAndroid | ModuleDescriptorIos | ModuleDescriptorDevTools;
 export interface AndroidGradlePluginDescriptor {
     /**
      * Gradle plugin ID
@@ -141,4 +153,13 @@ export interface RawExpoModuleConfig {
          */
         gradlePlugins?: AndroidGradlePluginDescriptor[];
     };
+    /**
+     * DevTools-specific config.
+     */
+    devtools?: {
+        /**
+         * The webpage root directory for Expo CLI DevTools to serve the web resources.
+         */
+        webpageRoot: string;
+    };
 }
diff --git a/node_modules/expo-modules-autolinking/build/types.js.map b/node_modules/expo-modules-autolinking/build/types.js.map
index a58f572..db4a9be 100644
--- a/node_modules/expo-modules-autolinking/build/types.js.map
+++ b/node_modules/expo-modules-autolinking/build/types.js.map
@@ -1 +1 @@
-{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import { ExpoModuleConfig } from './ExpoModuleConfig';\n\nexport type SupportedPlatform = 'ios' | 'android' | 'web';\n\nexport interface SearchOptions {\n  // Available in the CLI\n  searchPaths: string[];\n  ignorePaths?: string[] | null;\n  exclude?: string[] | null;\n  platform: SupportedPlatform;\n  silent?: boolean;\n  nativeModulesDir?: string | null;\n\n  // Scratched from project's config\n  flags?: Record<string, any>;\n}\n\nexport interface ResolveOptions extends SearchOptions {\n  json?: boolean;\n}\n\nexport interface GenerateOptions extends ResolveOptions {\n  target: string;\n  namespace?: string;\n  empty?: boolean;\n}\n\nexport interface PatchReactImportsOptions {\n  podsRoot: string;\n  dryRun: boolean;\n}\n\nexport type PackageRevision = {\n  path: string;\n  version: string;\n  config?: ExpoModuleConfig;\n  duplicates?: PackageRevision[];\n};\n\nexport type SearchResults = {\n  [moduleName: string]: PackageRevision;\n};\n\nexport interface ModuleAndroidProjectInfo {\n  name: string;\n  sourceDir: string;\n}\n\nexport interface ModuleAndroidPluginInfo {\n  id: string;\n  sourceDir: string;\n}\n\nexport interface ModuleDescriptorAndroid {\n  packageName: string;\n  projects: ModuleAndroidProjectInfo[];\n  plugins?: ModuleAndroidPluginInfo[];\n  modules: string[];\n}\n\nexport interface ModuleIosPodspecInfo {\n  podName: string;\n  podspecDir: string;\n}\nexport interface ModuleDescriptorIos {\n  packageName: string;\n  pods: ModuleIosPodspecInfo[];\n  flags: Record<string, any> | undefined;\n  swiftModuleNames: string[];\n  modules: string[];\n  appDelegateSubscribers: string[];\n  reactDelegateHandlers: string[];\n  debugOnly: boolean;\n}\n\nexport type ModuleDescriptor = ModuleDescriptorAndroid | ModuleDescriptorIos;\n\nexport interface AndroidGradlePluginDescriptor {\n  /**\n   * Gradle plugin ID\n   */\n  id: string;\n\n  /**\n   * Artifact group\n   */\n  group: string;\n\n  /**\n   * Relative path to the gradle plugin directory\n   */\n  sourceDir: string;\n}\n\n/**\n * Represents a raw config from `expo-module.json`.\n */\nexport interface RawExpoModuleConfig {\n  /**\n   * An array of supported platforms.\n   */\n  platforms?: SupportedPlatform[];\n\n  /**\n   * iOS-specific config.\n   */\n  ios?: {\n    /**\n     * Names of Swift native modules classes to put to the generated modules provider file.\n     */\n    modules?: string[];\n\n    /**\n     * Names of Swift native modules classes to put to the generated modules provider file.\n     * @deprecated Deprecated in favor of `modules`. Might be removed in the future releases.\n     */\n    modulesClassNames?: string[];\n\n    /**\n     * Names of Swift classes that hooks into `ExpoAppDelegate` to receive AppDelegate life-cycle events.\n     */\n    appDelegateSubscribers?: string[];\n\n    /**\n     * Names of Swift classes that implement `ExpoReactDelegateHandler` to hook React instance creation.\n     */\n    reactDelegateHandlers?: string[];\n\n    /**\n     * Podspec relative path.\n     * To have multiple podspecs, string array type is also supported.\n     */\n    podspecPath?: string | string[];\n\n    /**\n     * Swift product module name. If empty, the pod name is used for Swift imports.\n     * To have multiple modules, string array is also supported.\n     */\n    swiftModuleName?: string | string[];\n\n    /**\n     * Whether this module will be added only to the debug configuration.\n     * Defaults to false.\n     */\n    debugOnly?: boolean;\n  };\n\n  /**\n   * Android-specific config.\n   */\n  android?: {\n    /**\n     * Full names (package + class name) of Kotlin native modules classes to put to the generated package provider file.\n     */\n    modules?: string[];\n\n    /**\n     * Full names (package + class name) of Kotlin native modules classes to put to the generated package provider file.\n     * @deprecated Deprecated in favor of `modules`. Might be removed in the future releases.\n     */\n    modulesClassNames?: string[];\n\n    /**\n     * build.gradle relative path.\n     * To have multiple build.gradle projects, string array type is also supported.\n     */\n    gradlePath?: string | string[];\n\n    /**\n     * Gradle plugins.\n     */\n    gradlePlugins?: AndroidGradlePluginDescriptor[];\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import { ExpoModuleConfig } from './ExpoModuleConfig';\n\nexport type SupportedPlatform = 'ios' | 'android' | 'web' | 'devtools';\n\nexport interface SearchOptions {\n  // Available in the CLI\n  searchPaths: string[];\n  ignorePaths?: string[] | null;\n  exclude?: string[] | null;\n  platform: SupportedPlatform;\n  silent?: boolean;\n  nativeModulesDir?: string | null;\n  projectRoot: string;\n  /**\n   * Filter the search results to only include the project dependencies.\n   * In a monorepo, you may like to set this to false and link all modules from the monorepo.\n   * @default true\n   */\n  onlyProjectDeps?: boolean;\n\n  // Scratched from project's config\n  flags?: Record<string, any>;\n}\n\nexport interface ResolveOptions extends SearchOptions {\n  json?: boolean;\n}\n\nexport interface GenerateOptions extends ResolveOptions {\n  target: string;\n  namespace?: string;\n  empty?: boolean;\n}\n\nexport interface PatchReactImportsOptions {\n  podsRoot: string;\n  dryRun: boolean;\n}\n\nexport type PackageRevision = {\n  path: string;\n  version: string;\n  config?: ExpoModuleConfig;\n  duplicates?: PackageRevision[];\n};\n\nexport type SearchResults = {\n  [moduleName: string]: PackageRevision;\n};\n\nexport interface ModuleAndroidProjectInfo {\n  name: string;\n  sourceDir: string;\n}\n\nexport interface ModuleAndroidPluginInfo {\n  id: string;\n  sourceDir: string;\n}\n\nexport interface ModuleDescriptorAndroid {\n  packageName: string;\n  projects: ModuleAndroidProjectInfo[];\n  plugins?: ModuleAndroidPluginInfo[];\n  modules: string[];\n}\n\nexport interface ModuleIosPodspecInfo {\n  podName: string;\n  podspecDir: string;\n}\nexport interface ModuleDescriptorIos {\n  packageName: string;\n  pods: ModuleIosPodspecInfo[];\n  flags: Record<string, any> | undefined;\n  swiftModuleNames: string[];\n  modules: string[];\n  appDelegateSubscribers: string[];\n  reactDelegateHandlers: string[];\n  debugOnly: boolean;\n}\n\nexport interface ModuleDescriptorDevTools {\n  packageName: string;\n  packageRoot: string;\n  webpageRoot: string;\n}\n\nexport type ModuleDescriptor =\n  | ModuleDescriptorAndroid\n  | ModuleDescriptorIos\n  | ModuleDescriptorDevTools;\n\nexport interface AndroidGradlePluginDescriptor {\n  /**\n   * Gradle plugin ID\n   */\n  id: string;\n\n  /**\n   * Artifact group\n   */\n  group: string;\n\n  /**\n   * Relative path to the gradle plugin directory\n   */\n  sourceDir: string;\n}\n\n/**\n * Represents a raw config from `expo-module.json`.\n */\nexport interface RawExpoModuleConfig {\n  /**\n   * An array of supported platforms.\n   */\n  platforms?: SupportedPlatform[];\n\n  /**\n   * iOS-specific config.\n   */\n  ios?: {\n    /**\n     * Names of Swift native modules classes to put to the generated modules provider file.\n     */\n    modules?: string[];\n\n    /**\n     * Names of Swift native modules classes to put to the generated modules provider file.\n     * @deprecated Deprecated in favor of `modules`. Might be removed in the future releases.\n     */\n    modulesClassNames?: string[];\n\n    /**\n     * Names of Swift classes that hooks into `ExpoAppDelegate` to receive AppDelegate life-cycle events.\n     */\n    appDelegateSubscribers?: string[];\n\n    /**\n     * Names of Swift classes that implement `ExpoReactDelegateHandler` to hook React instance creation.\n     */\n    reactDelegateHandlers?: string[];\n\n    /**\n     * Podspec relative path.\n     * To have multiple podspecs, string array type is also supported.\n     */\n    podspecPath?: string | string[];\n\n    /**\n     * Swift product module name. If empty, the pod name is used for Swift imports.\n     * To have multiple modules, string array is also supported.\n     */\n    swiftModuleName?: string | string[];\n\n    /**\n     * Whether this module will be added only to the debug configuration.\n     * Defaults to false.\n     */\n    debugOnly?: boolean;\n  };\n\n  /**\n   * Android-specific config.\n   */\n  android?: {\n    /**\n     * Full names (package + class name) of Kotlin native modules classes to put to the generated package provider file.\n     */\n    modules?: string[];\n\n    /**\n     * Full names (package + class name) of Kotlin native modules classes to put to the generated package provider file.\n     * @deprecated Deprecated in favor of `modules`. Might be removed in the future releases.\n     */\n    modulesClassNames?: string[];\n\n    /**\n     * build.gradle relative path.\n     * To have multiple build.gradle projects, string array type is also supported.\n     */\n    gradlePath?: string | string[];\n\n    /**\n     * Gradle plugins.\n     */\n    gradlePlugins?: AndroidGradlePluginDescriptor[];\n  };\n\n  /**\n   * DevTools-specific config.\n   */\n  devtools?: {\n    /**\n     * The webpage root directory for Expo CLI DevTools to serve the web resources.\n     */\n    webpageRoot: string;\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-modules-autolinking/exports.d.ts b/node_modules/expo-modules-autolinking/exports.d.ts
new file mode 100644
index 0000000..e6aaf0c
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/exports.d.ts
@@ -0,0 +1 @@
+export * from './build/autolinking';
diff --git a/node_modules/expo-modules-autolinking/exports.js b/node_modules/expo-modules-autolinking/exports.js
new file mode 100644
index 0000000..9b5fc1a
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/exports.js
@@ -0,0 +1 @@
+module.exports = require('./build/autolinking');
diff --git a/node_modules/expo-modules-autolinking/src/ReactImportsPatcher.ts b/node_modules/expo-modules-autolinking/src/ReactImportsPatcher.ts
index ca06913..7625652 100644
--- a/node_modules/expo-modules-autolinking/src/ReactImportsPatcher.ts
+++ b/node_modules/expo-modules-autolinking/src/ReactImportsPatcher.ts
@@ -36,7 +36,7 @@ export async function patchFileAsync(headerSet: Set<string>, file: string, dryRu
   let changed = false;
   const content = await fs.readFile(file, 'utf-8');
   let transformContent = content.replace(
-    /^#import\s+"(.+)"$/gm,
+    /(?<=^\s*)#import\s+"(.+)"(?=\s*$)/gm,
     (match: string, headerName: string): string => {
       // `#import "RCTBridge.h"` -> `#import <React/RCTBridge.h>`
       if (headerSet.has(headerName)) {
@@ -59,7 +59,7 @@ export async function patchFileAsync(headerSet: Set<string>, file: string, dryRu
   );
 
   transformContent = transformContent.replace(
-    /^#(if|elif)\s+__has_include\("(.+)"\)$/gm,
+    /(?<=^\s*)#(if|elif)\s+__has_include\("(.+)"\)(?=\s*$)/gm,
     (match: string, ifPrefix: string, headerName: string): string => {
       // `#if __has_include("RCTBridge.h")` -> `#if __has_include(<React/RCTBridge.h>)`
       if (headerSet.has(headerName)) {
diff --git a/node_modules/expo-modules-autolinking/src/autolinking/extraDependencies.ts b/node_modules/expo-modules-autolinking/src/autolinking/extraDependencies.ts
index 7d265a9..58416fe 100644
--- a/node_modules/expo-modules-autolinking/src/autolinking/extraDependencies.ts
+++ b/node_modules/expo-modules-autolinking/src/autolinking/extraDependencies.ts
@@ -1,7 +1,7 @@
 import { getConfig } from '@expo/config';
 import path from 'path';
 
-import { projectPackageJsonPath } from './mergeLinkingOptions';
+import { getProjectPackageJsonPathAsync } from './mergeLinkingOptions';
 
 interface AndroidMavenRepository {
   url: string;
@@ -30,9 +30,9 @@ interface ExtraDependencies {
 /**
  * Gets the `expo-build-properties` settings from the app config.
  */
-export async function getBuildPropertiesAsync(): Promise<Record<string, any>> {
-  const projectRoot = path.dirname(projectPackageJsonPath);
-  const { exp: config } = await getConfig(projectRoot, { skipSDKVersionRequirement: true });
+export async function getBuildPropertiesAsync(projectRoot: string): Promise<Record<string, any>> {
+  const projectPackageRoot = path.dirname(await getProjectPackageJsonPathAsync(projectRoot));
+  const { exp: config } = await getConfig(projectPackageRoot, { skipSDKVersionRequirement: true });
   const buildPropertiesPlugin = config.plugins?.find(
     (item) => item[0] === 'expo-build-properties'
   )?.[1];
@@ -42,8 +42,10 @@ export async function getBuildPropertiesAsync(): Promise<Record<string, any>> {
 /**
  * Resolves the extra dependencies from `expo-build-properties` settings.
  */
-export async function resolveExtraDependenciesAsync(): Promise<Partial<ExtraDependencies>> {
-  const buildProps = await getBuildPropertiesAsync();
+export async function resolveExtraDependenciesAsync(
+  projectRoot: string
+): Promise<Partial<ExtraDependencies>> {
+  const buildProps = await getBuildPropertiesAsync(projectRoot);
   return {
     androidMavenRepos: buildProps.android?.extraMavenRepos ?? [],
     iosPods: buildProps.ios?.extraPods ?? {},
diff --git a/node_modules/expo-modules-autolinking/src/autolinking/findModules.ts b/node_modules/expo-modules-autolinking/src/autolinking/findModules.ts
index 7b86a14..ebf7fdc 100644
--- a/node_modules/expo-modules-autolinking/src/autolinking/findModules.ts
+++ b/node_modules/expo-modules-autolinking/src/autolinking/findModules.ts
@@ -6,7 +6,7 @@ import path from 'path';
 
 import { requireAndResolveExpoModuleConfig } from '../ExpoModuleConfig';
 import { PackageRevision, SearchOptions, SearchResults } from '../types';
-import { mergeLinkingOptionsAsync, projectPackageJsonPath } from './mergeLinkingOptions';
+import { getProjectPackageJsonPathAsync, mergeLinkingOptionsAsync } from './mergeLinkingOptions';
 
 // Names of the config files. From lowest to highest priority.
 const EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];
@@ -70,11 +70,11 @@ export async function findModulesAsync(providedOptions: SearchOptions): Promise<
   // (excluding custom native modules path)
   // Workspace root usually doesn't specify all its dependencies (see Expo Go),
   // so in this case we should link everything.
-  if (options.searchPaths.length <= 1) {
+  if (options.searchPaths.length <= 1 || options.onlyProjectDeps === false) {
     return searchResults;
   }
 
-  return filterToProjectDependencies(searchResults, {
+  return await filterToProjectDependenciesAsync(searchResults, {
     ...providedOptions,
     // Custom native modules are not filtered out
     // when they're not specified in package.json dependencies.
@@ -180,10 +180,12 @@ function resolvePackageNameAndVersion(
 /**
  * Filters out packages that are not the dependencies of the project.
  */
-function filterToProjectDependencies(
+async function filterToProjectDependenciesAsync(
   results: SearchResults,
-  options: Pick<SearchOptions, 'silent'> & { alwaysIncludedPackagesNames?: Set<string> } = {}
-) {
+  options: Pick<SearchOptions, 'projectRoot' | 'silent'> & {
+    alwaysIncludedPackagesNames?: Set<string>;
+  }
+): Promise<SearchResults> {
   const filteredResults: SearchResults = {};
   const visitedPackages = new Set<string>();
 
@@ -244,6 +246,7 @@ function filterToProjectDependencies(
   }
 
   // Visit project's package.
+  const projectPackageJsonPath = await getProjectPackageJsonPathAsync(options.projectRoot);
   visitPackage(projectPackageJsonPath);
 
   return filteredResults;
diff --git a/node_modules/expo-modules-autolinking/src/autolinking/index.ts b/node_modules/expo-modules-autolinking/src/autolinking/index.ts
index 3608f20..153c806 100644
--- a/node_modules/expo-modules-autolinking/src/autolinking/index.ts
+++ b/node_modules/expo-modules-autolinking/src/autolinking/index.ts
@@ -1,12 +1,22 @@
-export {
-  // NOTE(evanbacon): Used in @expo/prebuild-config
-  findModulesAsync,
-} from './findModules';
-export {
-  // NOTE(evanbacon): Used in @expo/prebuild-config
-  resolveSearchPathsAsync,
-  mergeLinkingOptionsAsync,
-} from './mergeLinkingOptions';
+import { findModulesAsync } from './findModules';
+import { mergeLinkingOptionsAsync, resolveSearchPathsAsync } from './mergeLinkingOptions';
+import { resolveModulesAsync } from './resolveModules';
+import type { ModuleDescriptor, SearchOptions } from '../types';
+
+export { findModulesAsync, mergeLinkingOptionsAsync, resolveModulesAsync, resolveSearchPathsAsync };
 export { generatePackageListAsync } from './generatePackageList';
-export { resolveModulesAsync } from './resolveModules';
 export { verifySearchResults } from './verifySearchResults';
+export * from '../types';
+
+/**
+ * Programmatic API to query autolinked modules for a project.
+ */
+export async function queryAutolinkingModulesFromProjectAsync(
+  projectRoot: string,
+  options: Pick<SearchOptions, 'platform' | 'exclude' | 'onlyProjectDeps'>
+): Promise<ModuleDescriptor[]> {
+  const searchPaths = await resolveSearchPathsAsync(null, projectRoot);
+  const linkOptions = await mergeLinkingOptionsAsync({ ...options, projectRoot, searchPaths });
+  const searchResults = await findModulesAsync(linkOptions);
+  return await resolveModulesAsync(searchResults, linkOptions);
+}
diff --git a/node_modules/expo-modules-autolinking/src/autolinking/mergeLinkingOptions.ts b/node_modules/expo-modules-autolinking/src/autolinking/mergeLinkingOptions.ts
index 76080dd..10da601 100644
--- a/node_modules/expo-modules-autolinking/src/autolinking/mergeLinkingOptions.ts
+++ b/node_modules/expo-modules-autolinking/src/autolinking/mergeLinkingOptions.ts
@@ -5,13 +5,14 @@ import path from 'path';
 import { SearchOptions } from '../types';
 
 /**
- * Path to the `package.json` of the closest project in the current working dir.
+ * Find the path to the `package.json` of the closest project in the given project root.
  */
-export const projectPackageJsonPath = findUp.sync('package.json', { cwd: process.cwd() }) as string;
-
-// This won't happen in usual scenarios, but we need to unwrap the optional path :)
-if (!projectPackageJsonPath) {
-  throw new Error(`Couldn't find "package.json" up from path "${process.cwd()}"`);
+export async function getProjectPackageJsonPathAsync(projectRoot: string): Promise<string> {
+  const result = await findUp('package.json', { cwd: projectRoot });
+  if (!result) {
+    throw new Error(`Couldn't find "package.json" up from path "${projectRoot}"`);
+  }
+  return result;
 }
 
 /**
@@ -23,7 +24,7 @@ if (!projectPackageJsonPath) {
 export async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(
   providedOptions: OptionsType
 ): Promise<OptionsType> {
-  const packageJson = require(projectPackageJsonPath);
+  const packageJson = require(await getProjectPackageJsonPathAsync(providedOptions.projectRoot));
   const baseOptions = packageJson.expo?.autolinking;
   const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];
   const finalOptions = Object.assign(
@@ -34,11 +35,14 @@ export async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions
   ) as OptionsType;
 
   // Makes provided paths absolute or falls back to default paths if none was provided.
-  finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());
+  finalOptions.searchPaths = await resolveSearchPathsAsync(
+    finalOptions.searchPaths,
+    providedOptions.projectRoot
+  );
 
   finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(
     finalOptions.nativeModulesDir,
-    process.cwd()
+    providedOptions.projectRoot
   );
 
   return finalOptions;
diff --git a/node_modules/expo-modules-autolinking/src/autolinking/verifySearchResults.ts b/node_modules/expo-modules-autolinking/src/autolinking/verifySearchResults.ts
index e1e3de8..d2d030f 100644
--- a/node_modules/expo-modules-autolinking/src/autolinking/verifySearchResults.ts
+++ b/node_modules/expo-modules-autolinking/src/autolinking/verifySearchResults.ts
@@ -1,14 +1,14 @@
 import chalk from 'chalk';
 import path from 'path';
 
-import { PackageRevision, SearchResults } from '../types';
+import { PackageRevision, SearchOptions, SearchResults } from '../types';
 
 /**
  * Verifies the search results by checking whether there are no duplicates.
  */
-export function verifySearchResults(searchResults: SearchResults): number {
-  const cwd = process.cwd();
-  const relativePath: (pkg: PackageRevision) => string = (pkg) => path.relative(cwd, pkg.path);
+export function verifySearchResults(searchResults: SearchResults, options: SearchOptions): number {
+  const relativePath: (pkg: PackageRevision) => string = (pkg) =>
+    path.relative(options.projectRoot, pkg.path);
   let counter = 0;
 
   for (const moduleName in searchResults) {
diff --git a/node_modules/expo-modules-autolinking/src/index.ts b/node_modules/expo-modules-autolinking/src/index.ts
index fe35379..cc3d8db 100644
--- a/node_modules/expo-modules-autolinking/src/index.ts
+++ b/node_modules/expo-modules-autolinking/src/index.ts
@@ -36,6 +36,18 @@ function registerSearchCommand<OptionsType extends SearchOptions>(
       'ios'
     )
     .option('--silent', 'Silence resolution warnings')
+    .addOption(
+      new commander.Option(
+        '--project-root <projectRoot>',
+        'The path to the root of the project'
+      ).default(process.cwd(), 'process.cwd()')
+    )
+    .option(
+      '--only-project-deps',
+      'For a monorepo, include all modules even if they are not in the project dependencies.',
+      true
+    )
+    .option('--no-only-project-deps', 'Opposite of --only-project-deps', false)
     .action(async (searchPaths, providedOptions) => {
       const options = await mergeLinkingOptionsAsync<OptionsType>({
         ...providedOptions,
@@ -76,8 +88,8 @@ module.exports = async function (args: string[]) {
   }).option<boolean>('-j, --json', 'Output results in the plain JSON format.', () => true, false);
 
   // Checks whether there are no resolving issues in the current setup.
-  registerSearchCommand('verify', (results) => {
-    const numberOfDuplicates = verifySearchResults(results);
+  registerSearchCommand('verify', (results, options) => {
+    const numberOfDuplicates = verifySearchResults(results, options);
     if (!numberOfDuplicates) {
       console.log('✅ Everything is fine!');
     }
@@ -86,7 +98,7 @@ module.exports = async function (args: string[]) {
   // Searches for available expo modules and resolves the results for given platform.
   registerResolveCommand('resolve', async (results, options) => {
     const modules = await resolveModulesAsync(results, options);
-    const extraDependencies = await resolveExtraDependenciesAsync();
+    const extraDependencies = await resolveExtraDependenciesAsync(options.projectRoot);
 
     if (options.json) {
       console.log(JSON.stringify({ extraDependencies, modules }));
diff --git a/node_modules/expo-modules-autolinking/src/platforms/devtools.ts b/node_modules/expo-modules-autolinking/src/platforms/devtools.ts
new file mode 100644
index 0000000..7dc7acb
--- /dev/null
+++ b/node_modules/expo-modules-autolinking/src/platforms/devtools.ts
@@ -0,0 +1,19 @@
+import path from 'path';
+
+import { ModuleDescriptorDevTools, PackageRevision } from '../types';
+
+export async function resolveModuleAsync(
+  packageName: string,
+  revision: PackageRevision
+): Promise<ModuleDescriptorDevTools | null> {
+  const devtoolsConfig = revision.config?.toJSON().devtools;
+  if (devtoolsConfig == null) {
+    return null;
+  }
+
+  return {
+    packageName,
+    packageRoot: revision.path,
+    webpageRoot: path.join(revision.path, devtoolsConfig.webpageRoot),
+  };
+}
diff --git a/node_modules/expo-modules-autolinking/src/types.ts b/node_modules/expo-modules-autolinking/src/types.ts
index 25f6899..8c931fc 100644
--- a/node_modules/expo-modules-autolinking/src/types.ts
+++ b/node_modules/expo-modules-autolinking/src/types.ts
@@ -1,6 +1,6 @@
 import { ExpoModuleConfig } from './ExpoModuleConfig';
 
-export type SupportedPlatform = 'ios' | 'android' | 'web';
+export type SupportedPlatform = 'ios' | 'android' | 'web' | 'devtools';
 
 export interface SearchOptions {
   // Available in the CLI
@@ -10,6 +10,13 @@ export interface SearchOptions {
   platform: SupportedPlatform;
   silent?: boolean;
   nativeModulesDir?: string | null;
+  projectRoot: string;
+  /**
+   * Filter the search results to only include the project dependencies.
+   * In a monorepo, you may like to set this to false and link all modules from the monorepo.
+   * @default true
+   */
+  onlyProjectDeps?: boolean;
 
   // Scratched from project's config
   flags?: Record<string, any>;
@@ -73,7 +80,16 @@ export interface ModuleDescriptorIos {
   debugOnly: boolean;
 }
 
-export type ModuleDescriptor = ModuleDescriptorAndroid | ModuleDescriptorIos;
+export interface ModuleDescriptorDevTools {
+  packageName: string;
+  packageRoot: string;
+  webpageRoot: string;
+}
+
+export type ModuleDescriptor =
+  | ModuleDescriptorAndroid
+  | ModuleDescriptorIos
+  | ModuleDescriptorDevTools;
 
 export interface AndroidGradlePluginDescriptor {
   /**
@@ -171,4 +187,14 @@ export interface RawExpoModuleConfig {
      */
     gradlePlugins?: AndroidGradlePluginDescriptor[];
   };
+
+  /**
+   * DevTools-specific config.
+   */
+  devtools?: {
+    /**
+     * The webpage root directory for Expo CLI DevTools to serve the web resources.
+     */
+    webpageRoot: string;
+  };
 }
